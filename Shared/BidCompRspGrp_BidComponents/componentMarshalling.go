package BidCompRspGrp_BidComponents

import "bufio"
import "strconv"
import "fmt"

// Autogenerated at , do not edit




func (m *BidCompRspGrp_BidComponents) MarshalFIX(res *bufio.Writer) error {
    var err error
    
    if m.Commission.HasValue() {
        (*res).WriteString("12=")
        val, err := m.Commission.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.CommType.HasValue() {
        (*res).WriteString("13=")
        val, err := m.CommType.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.CommCurrency.HasValue() {
        (*res).WriteString("479=")
        val, err := m.CommCurrency.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.FundRenewWaiv.HasValue() {
        (*res).WriteString("497=")
        val, err := m.FundRenewWaiv.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.ListID.HasValue() {
        (*res).WriteString("66=")
        val, err := m.ListID.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.Country.HasValue() {
        (*res).WriteString("421=")
        val, err := m.Country.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.Side.HasValue() {
        (*res).WriteString("54=")
        val, err := m.Side.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.Price.HasValue() {
        (*res).WriteString("44=")
        val, err := m.Price.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.PriceType.HasValue() {
        (*res).WriteString("423=")
        val, err := m.PriceType.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.FairValue.HasValue() {
        (*res).WriteString("406=")
        val, err := m.FairValue.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.NetGrossInd.HasValue() {
        (*res).WriteString("430=")
        val, err := m.NetGrossInd.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.SettlType.HasValue() {
        (*res).WriteString("63=")
        val, err := m.SettlType.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.SettlDate.HasValue() {
        (*res).WriteString("64=")
        val, err := m.SettlDate.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.TradingSessionID.HasValue() {
        (*res).WriteString("336=")
        val, err := m.TradingSessionID.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.TradingSessionSubID.HasValue() {
        (*res).WriteString("625=")
        val, err := m.TradingSessionSubID.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.Text.HasValue() {
        (*res).WriteString("58=")
        val, err := m.Text.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.EncodedTextLen.HasValue() {
        (*res).WriteString("354=")
        val, err := m.EncodedTextLen.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    if m.EncodedText.HasValue() {
        (*res).WriteString("355=")
        val, err := m.EncodedText.MarshalFIX()
        if err != nil {
            return err
        }
        (*res).Write(val)
        (*res).WriteString("\x01")
    }
    return err
}

func (m *BidCompRspGrp_BidComponents) UnmarshalFIX(input io.Reader) error {
    var err error
    var field []byte
    for field, err = input.ReadSlice([]byte("\x01")); err == nil {
        slices = bytes.Split(field, []byte("="))
        if len(slices) != 2 {
            // TODO handle data fields
            err = errors.New(fmt.Sprintf("Found field without seperator '=' (%s)", string(field))
        } else {
            var used bool
            used, err m.UnmarshalFieldFIX(strconv.Atoi(string(slices[0])), slices[1])
            if !used {
                err = errors.New(fmt.Sprintf("Field unused by message BidCompRspGrp_BidComponents (%s)", string(field)))
            }
        }
        if err != nil {
            break
        }
    }
    return err
}


func (m *BidCompRspGrp_BidComponents) UnmarshalFieldFIX(id int, value []byte) (bool, error) {
    // Check if we are currently populating a group
    used := false
    var err error = nil
    for !used && m._controlBlock.mostRecentRepeatingGroup != nil {
        used = m._controlBlock.mostRecentRepeatingGroup[m._controlBlock.mostRecentRepeatingGroupCounter].PopulateNextFieldById(id, value)
        if !used {
            // This group did not need use the latest field, and has all its mandatory fields, so consider it complete.
            m._controlBlock.mostRecentRepeatingGroupCounter++
            if m._controlBlock.mostRecentRepeatingGroupCounter >= len(m._controlBlock.mostRecentRepeatingGroup)  {
                // we have all the repeated groups we expected.
                m._controlBlock.mostRecentRepeatingGroup = nil
            }
        }
    }
    
    // If one of the groups did not consume the KV, try our own fields 
    if !used {
        switch id {
        
        case 12:
            if !m.Commission.HasValue() {
                used = true
                err = m.Commission.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 13:
            if !m.CommType.HasValue() {
                used = true
                err = m.CommType.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 479:
            if !m.CommCurrency.HasValue() {
                used = true
                err = m.CommCurrency.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 497:
            if !m.FundRenewWaiv.HasValue() {
                used = true
                err = m.FundRenewWaiv.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 66:
            if !m.ListID.HasValue() {
                used = true
                err = m.ListID.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 421:
            if !m.Country.HasValue() {
                used = true
                err = m.Country.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 54:
            if !m.Side.HasValue() {
                used = true
                err = m.Side.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 44:
            if !m.Price.HasValue() {
                used = true
                err = m.Price.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 423:
            if !m.PriceType.HasValue() {
                used = true
                err = m.PriceType.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 406:
            if !m.FairValue.HasValue() {
                used = true
                err = m.FairValue.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 430:
            if !m.NetGrossInd.HasValue() {
                used = true
                err = m.NetGrossInd.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 63:
            if !m.SettlType.HasValue() {
                used = true
                err = m.SettlType.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 64:
            if !m.SettlDate.HasValue() {
                used = true
                err = m.SettlDate.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 336:
            if !m.TradingSessionID.HasValue() {
                used = true
                err = m.TradingSessionID.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 625:
            if !m.TradingSessionSubID.HasValue() {
                used = true
                err = m.TradingSessionSubID.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 58:
            if !m.Text.HasValue() {
                used = true
                err = m.Text.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 354:
            if !m.EncodedTextLen.HasValue() {
                used = true
                err = m.EncodedTextLen.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        
        case 355:
            if !m.EncodedText.HasValue() {
                used = true
                err = m.EncodedText.UnmarshalFIX(value)
                if err != nil {
                    return used, err
                }
            }
        
        
        default:
            used = false
        }
    }
   
    return used, err
}


